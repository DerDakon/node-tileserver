/*
node-tileserver Copyright (C) 2014 Alexander Matheisen
This program comes with ABSOLUTELY NO WARRANTY.
This is free software, and you are welcome to redistribute it under certain conditions.
See https://github.com/rurseekatze/node-tileserver for details.
*/


// load configuraion file
var configuration = require('./config.json');


// include necessary modules
var cluster = require('cluster');
var os = require('os');
var rbush = require('rbush');
var assert = require('assert');
var http = require("http");
var url = require("url");
var mkdirp = require('mkdirp');
var pg = require('pg');
var toobusy = require('toobusy');
var byline = require('byline');
var touch = require("touch");


// maximum count of concurrent http connections
http.globalAgent.maxSockets = configuration.maxsockets;


var Canvas = require('canvas');
Image = Canvas.Image;


var events = require('events');
eventEmitter = new events.EventEmitter();


// tag conditions for faster database queries, smaller tiles and faster rendering
// conditions are hardcoded for better results, but could also be generated by a stylefile parser
var condition = new Array();
condition[0] = "AND (tags->'usage'='main')";
condition[1] = "AND (tags->'usage'='main')";
condition[2] = "AND (tags->'usage'='main')";
condition[3] = "AND (tags->'usage'='main')";
condition[4] = "AND (tags->'usage'='main')";
condition[5] = "AND (tags->'usage'='main')";
condition[6] = "AND (tags->'usage'='main')";
condition[7] = "AND (tags->'usage'='main')";
condition[8] = "AND ((tags->'usage'='main') OR (tags->'usage'='branch'))";
condition[9] = "AND ((tags->'usage'='main') OR (tags->'usage'='branch') OR (tags->'railway'='disused') OR (tags->'railway'='abandoned') OR (tags->'railway'='proposed') OR (tags->'railway'='construction') OR (tags->'railway'='station') OR (tags->'railway'='narrow_gauge'))";
condition[10] = "AND ((tags->'railway'='rail') OR (tags->'railway'='disused') OR (tags->'railway'='abandoned') OR (tags->'railway'='proposed') OR (tags->'railway'='construction') OR (tags->'railway'='light_rail') OR (tags->'railway'='tram') OR (tags->'railway'='subway') OR (tags->'railway'='narrow_gauge') OR (tags->'railway'='station') OR (tags->'railway'='halt'))";


// include necessary libraries
logger.trace('Including KothicJS...');
eval(fs.readFileSync(configuration.scriptdir+'/kothic.js')+'');
eval(fs.readFileSync(configuration.scriptdir+'/renderer/path.js')+'');
eval(fs.readFileSync(configuration.scriptdir+'/renderer/line.js')+'');
eval(fs.readFileSync(configuration.scriptdir+'/renderer/polygon.js')+'');
eval(fs.readFileSync(configuration.scriptdir+'/renderer/shields.js')+'');
eval(fs.readFileSync(configuration.scriptdir+'/renderer/path.js')+'');
eval(fs.readFileSync(configuration.scriptdir+'/renderer/texticons.js')+'');
eval(fs.readFileSync(configuration.scriptdir+'/renderer/path.js')+'');
eval(fs.readFileSync(configuration.scriptdir+'/renderer/text.js')+'');
eval(fs.readFileSync(configuration.scriptdir+'/style/mapcss.js')+'');
eval(fs.readFileSync(configuration.scriptdir+'/style/style.js')+'');
eval(fs.readFileSync(configuration.scriptdir+'/utils/collisions.js')+'');
eval(fs.readFileSync(configuration.scriptdir+'/utils/geom.js')+'');
eval(fs.readFileSync(configuration.scriptdir+'/utils/collisions.js')+'');
logger.trace('KothicJS loaded.');


// workaround to emulate browser properties
var window = new Object;
window.devicePixelRatio = 1;

// workaround to emulate browser frame method
window.requestAnimationFrame = (
	function()
	{
		return function(callback)
		{
			callback();
		};
	}
)();

// workaround to emulate dom functions
var document = new Object;
document.createElement = function()
{
	return new Canvas();
}

// number of cpus
var cpus = os.cpus().length;


// renders a certain tile and calls the callback with the ready-rendered canvas when finished
function renderTile(zoom, x, y, styleName, features, callback)
{
	logger.debug('z'+zoom+'x'+x+'y'+y+' Rendering data...');

	// start bitmap rendering
	var canvas = new Canvas(configuration.tileSize, configuration.tileSize);
	canvas.style = new Object();

	MapCSS.invalidateCache();
	MapCSS.availableStyles.length = 0;
	MapCSS.availableStyles.push(styleName);

	Kothic.render(canvas, features, parseInt(zoom)+configuration.zoomOffset,
	{
		styles: MapCSS.availableStyles,
		onRenderComplete: function()
		{
			logger.debug('z'+zoom+'x'+x+'y'+y+' Finished rendering bitmap tile.');
			return process.nextTick(function()
			{
				callback(false, canvas);
			});
		}
	});
}


// requests objects for a certain tile and returns the data as an object
function getVectorData(x, y, z, callback)
{
	x = parseInt(x);
	y = parseInt(y);
	z = parseInt(z);
	var bbox = bboxByTile(z+1, x, y);
	var bbox_p = from4326To900913(bbox);
	var zoom = z+configuration.zoomOffset;

	var connection = "postgres://postgres@localhost/"+configuration.database;
	var client = new pg.Client(connection);

	logger.debug('z'+z+'x'+x+'y'+y+' Connecting to database '+connection+'...');
	client.connect(function(err)
	{
		if (err)
		{
			logger.error('z'+z+'x'+x+'y'+y+' Connection to database '+connection+' failed. Returning.');
			return process.nextTick(function()
			{
				callback(err, null);
			});
		}
		else
			logger.debug('z'+z+'x'+x+'y'+y+' Connected to database.');

		// request polygons
		var query = getDatabaseQuery("polygon", bbox_p, zoom);
		logger.trace('z'+z+'x'+x+'y'+y+' Requesting polygons...');
		client.query(query, function(err, polygons)
		{
			var features = getJSONFeatures(polygons.rows);
			// request lines
			var query = getDatabaseQuery("line", bbox_p, zoom);
			logger.trace('z'+z+'x'+x+'y'+y+' Requesting lines...');
			client.query(query, function(err, lines)
			{
				features = features.concat(getJSONFeatures(lines.rows));
				// request points
				var query = getDatabaseQuery("point", bbox_p, zoom);
				logger.trace('z'+z+'x'+x+'y'+y+' Requesting points...');
				client.query(query, function(err, points)
				{
					var content = new Object();
					content.features = new Array();

					logger.trace('z'+z+'x'+x+'y'+y+' All database queries finished, generating JSON data object.');
					content.features = features.concat(getJSONFeatures(points.rows));

					// catch tiles without data
					if (!content.features)
					{
						content.features = new Array();
						logger.debug('z'+z+'x'+x+'y'+y+' Vector tile contains no data.');
					}
			
					content.granularity = configuration.intscalefactor;
					content.bbox = bbox;
					client.end();
					invertYAxe(content);
					logger.debug('z'+z+'x'+x+'y'+y+' Generated vector data.');
					return process.nextTick(function()
					{
						callback(err, content);
					});
				});
			});
		});
	});
}


// converts raw JSON features from database response to objects
function getJSONFeatures(rows)
{
	var features = new Array();
	for (var i=0; i<rows.length; i++)
	{
		// catch JSON parsing errors
		try
		{
			var geojson = JSON.parse(rows[i][configuration.geomcolumn]);
		}
		catch (err)
		{
			break;
		}

		if (geojson.type == "GeometryCollection")
			continue;

		try
		{
			if (geojson.reprpoint)
				geojson.reprpoint = JSON.parse(rows[i].reprpoint.coordinates);
			geojson.properties = JSON.parse(rows[i].tags);
		}
		catch (err)
		{
			continue;
		}

		features.push(geojson);
	}
	return features;
}


// stores a vector tile in the vector tile directory
function saveVectorTile(data, x, y, z, callback)
{
	var filepath = configuration.vtiledir+'/'+z+'/'+x;
	logger.debug('z'+z+'x'+x+'y'+y+' Creating path '+filepath+'...');
	mkdirp(filepath, function(err)
	{
		if (err)
		{
			logger.error('z'+z+'x'+x+'y'+y+' Cannot create path: '+filepath+'. Returning.');
			return process.nextTick(function()
			{
				callback(err);
			});
		}

		logger.debug('z'+z+'x'+x+'y'+y+' Created path. Saving vector tile at path: '+filepath+'/'+y+'.json');
		fs.writeFile(filepath+'/'+y+'.json', data, {mode: 0777}, function(err)
		{
			if (err)
			{
				logger.error('z'+z+'x'+x+'y'+y+' Cannot save vector tile at path: '+filepath+'/'+y+'.json');
				return process.nextTick(function()
				{
					callback(err);
				});
			}

			logger.debug('z'+z+'x'+x+'y'+y+' Saved vector tile at path: '+filepath+'/'+y+'.json');
			return process.nextTick(function()
			{
				callback(false);
			});
		});
	});
}


// returns a database sql query string
function getDatabaseQuery(type, bbox, zoom)
{
	var cond = condition[zoom] || "";
	if (type == "polygon")
	{
		return "\
					SELECT\
						ST_AsGeoJSON(ST_TransScale(ST_ForceRHR(ST_Intersection(way, SetSRID('BOX3D("+bbox[0]+" "+bbox[1]+","+bbox[2]+" "+bbox[3]+")'::box3d, 900913))), "+(-bbox[0])+", "+(-bbox[1])+", "+configuration.intscalefactor/(bbox[2]-bbox[0])+", "+configuration.intscalefactor/(bbox[3]-bbox[1])+"), 0) AS "+configuration.geomcolumn+",\
						hstore2json(CAST(hstore(tags) AS hstore)) AS tags,\
						ST_AsGeoJSON(ST_TransScale(ST_ForceRHR(ST_PointOnSurface(way)), "+(-bbox[0])+", "+(-bbox[1])+", "+configuration.intscalefactor/(bbox[2]-bbox[0])+", "+configuration.intscalefactor/(bbox[3]-bbox[1])+"), 0) AS reprpoint\
					FROM\
						(\
							SELECT (ST_Dump(ST_Multi(ST_SimplifyPreserveTopology(ST_Buffer(way ,-"+pixelSizeAtZoom(zoom, configuration.pxtolerance)+"), "+pixelSizeAtZoom(zoom, configuration.pxtolerance)+")))).geom AS "+configuration.geomcolumn+", tags\
							FROM\
								(\
									SELECT ST_Union(way) AS "+configuration.geomcolumn+", tags\
									FROM\
										(\
											SELECT ST_Buffer(way, "+pixelSizeAtZoom(zoom, configuration.pxtolerance)+") AS "+configuration.geomcolumn+", CAST(tags AS text) AS tags\
											FROM "+configuration.prefix+"_polygon\
											WHERE way && SetSRID('BOX3D("+bbox[0]+" "+bbox[1]+","+bbox[2]+" "+bbox[3]+")'::box3d, 900913) AND way_area > "+(Math.pow(pixelSizeAtZoom(zoom, configuration.pxtolerance), 2)/configuration.pxtolerance)+" "+cond+"\
										) p\
									GROUP BY CAST(tags AS text)\
								) p\
							WHERE ST_Area(way) > "+Math.pow(pixelSizeAtZoom(zoom, configuration.pxtolerance), 2)+"\
							ORDER BY ST_Area(way)\
						) p";
	}
	else if (type == "line")
	{
		return "\
					SELECT\
						ST_AsGeoJSON(ST_TransScale(ST_Intersection(way, SetSRID('BOX3D("+bbox[0]+" "+bbox[1]+","+bbox[2]+" "+bbox[3]+")'::box3d, 900913)), "+(-bbox[0])+", "+(-bbox[1])+", "+(configuration.intscalefactor/(bbox[2]-bbox[0]))+", "+(configuration.intscalefactor/(bbox[3]-bbox[1]))+"), 0) AS "+configuration.geomcolumn+", hstore2json(CAST(hstore(tags) AS hstore)) as tags\
					FROM\
						(\
							SELECT (ST_Dump(ST_Multi(ST_SimplifyPreserveTopology(ST_LineMerge(way), "+pixelSizeAtZoom(zoom, configuration.pxtolerance)+")))).geom AS "+configuration.geomcolumn+", tags\
							FROM\
								(\
									SELECT ST_Union(way) AS "+configuration.geomcolumn+", CAST(tags AS text)\
									FROM "+configuration.prefix+"_line\
									WHERE way && SetSRID('BOX3D("+bbox[0]+" "+bbox[1]+","+bbox[2]+" "+bbox[3]+")'::box3d, 900913) "+cond+"\
									GROUP BY CAST(tags AS text)\
								) p\
						) p";
	}
	else if (type == "point")
	{
		var tolerance = pixelSizeAtZoom(zoom, configuration.tileBoundTolerance);

		return "\
					SELECT ST_AsGeoJSON(ST_TransScale(way, "+(-bbox[0])+", "+(-bbox[1])+", "+(configuration.intscalefactor/(bbox[2]-bbox[0]))+", "+(configuration.intscalefactor/(bbox[3]-bbox[1]))+"), 0) AS "+configuration.geomcolumn+", hstore2json(tags) AS tags\
					FROM "+configuration.prefix+"_point\
					WHERE\
			        way && SetSRID('BOX3D("+(bbox[0]-tolerance)+" "+(bbox[1]-tolerance)+","+(bbox[2]+tolerance)+" "+(bbox[3]+tolerance)+")'::box3d, 900913) "+cond+"\
					LIMIT 10000";
	}
}


// equivalent of tanh in PHP
function tanh(i)
{
	return (Math.exp(i) - Math.exp(-i)) / (Math.exp(i) + Math.exp(-i));
}


// equivalent of rad2deg in PHP
function rad2deg(angle)
{
	return angle/(Math.PI/180.0);
}


// equivalent of deg2rad in PHP
function deg2rad(angle)
{
	return angle*(Math.PI/180.0);
}


// adds a callback function to the data to make it usable for browser rendering
function getVectorDataString(data, x, y, z)
{
	return "onKothicDataResponse("+data+","+z+","+x+","+y+");";
}


// Wrapper around transform call for convenience. Transforms line from EPSG:900913 to EPSG:4326
// line - a list of [lat0,lon0,lat1,lon1,...] or [(lat0,lon0),(lat1,lon1),...]
function from900913To4326(line)
{
	var serial = false;
	if (!Array.isArray(line[0]))
	{
		serial = true;
		var l1 = new Array();
		for (var i=0; i<line.length; i=i+2)
			l1.push(new Array(line[i], line[i+1]));
		line = l1;
	}
	var ans = new Array();
	for (var i=0; i<line.length; i++)
	{
		var xtile = line[i][0]/111319.49079327358;
		var ytile = rad2deg(Math.asin(tanh(line[i][1]/20037508.342789244*Math.PI)));
		if (serial)
		{
			ans.push(xtile);
			ans.push(ytile);
		}
		else
			ans.push(new Array(xtile, ytile));
	}
	return ans;
}


// Wrapper around transform call for convenience. Transforms line from EPSG:4326 to EPSG:900913
// line - a list of [lat0,lon0,lat1,lon1,...] or [(lat0,lon0),(lat1,lon1),...]
function from4326To900913(line)
{
	var serial = false;
	if (!Array.isArray(line[0]))
	{
		serial = true;
		var l1 = new Array();
		for (var i=0; i<line.length; i=i+2)
			l1.push(new Array(line[i], line[i+1]));
		var line = l1;
	}

	var ans = new Array();
	for (var i=0; i<line.length; i++)
	{
		var latRad = deg2rad(line[i][1]);
	  	var xtile = line[i][0]*111319.49079327358;
	  	var ytile = Math.log(Math.tan(latRad) + (1 / Math.cos(latRad))) / Math.PI * 20037508.342789244;

		if (serial)
		{
			ans.push(xtile);
			ans.push(ytile);
		}
		else
			ans.push(new Array(xtile, ytile));
	}

	return ans;
}


// returns the content of a vector tile as a string
function readVectorTile(x, y, z, callback)
{
	var path = configuration.vtiledir+'/'+z+'/'+x+'/'+y+'.json';
	logger.debug('z'+z+'x'+x+'y'+y+' Reading vector tile at path: '+path);
	fs.readFile(path, function(err, data)
	{
		if (!err && data)
		{
			logger.debug('z'+z+'x'+x+'y'+y+' Loaded data from vector tile: '+path);
			return process.nextTick(function()
			{
				// catch JSON parsing errors
				try
				{
					var jsondata = JSON.parse(data);
					callback(err, jsondata);
				}
				catch (err)
				{
					callback(true, null);
				}
			});
		}
		else
		{
			logger.debug('z'+z+'x'+x+'y'+y+' Cannot read vector tile: '+path);
			return process.nextTick(function()
			{
				callback(err, null);
			});
		}
	});
}


// helper function to invert the y axe of the data
function invertYAxe(data)
{
	var type, coordinates, tileSize = data.granularity, i, j, k, l, feature;

	for (i = 0; i < data.features.length; i++)
	{
	    feature = data.features[i];
	    coordinates = feature.coordinates;
	    type = data.features[i].type;
	    if (type === 'Point')
	        coordinates[1] = tileSize - coordinates[1];
		else if (type === 'MultiPoint' || type === 'LineString')
	        for (j = 0; j < coordinates.length; j++) 
	            coordinates[j][1] = tileSize - coordinates[j][1];
		else if (type === 'MultiLineString' || type === 'Polygon')
	        for (k = 0; k < coordinates.length; k++)
	            for (j = 0; j < coordinates[k].length; j++)
	                coordinates[k][j][1] = tileSize - coordinates[k][j][1];
		else if (type === 'MultiPolygon')
	        for (l = 0; l < coordinates.length; l++)
	            for (k = 0; k < coordinates[l].length; k++)
	                for (j = 0; j < coordinates[l][k].length; j++)
	                    coordinates[l][k][j][1] = tileSize - coordinates[l][k][j][1];
		else
	        throw "Unexpected GeoJSON type: " + type;

	    if (feature.hasOwnProperty('reprpoint'))
	        feature.reprpoint[1] = tileSize - feature.reprpoint[1];
	}
}


// Converts l pixels on tiles into length on zoom z
function pixelSizeAtZoom(z, l)
{
	l = l || 1;
	return l*20037508.342789244 / 256*2 / Math.pow(2, z);
}


// Tile numbers of given zoom level to EPSG:4326 bbox of a tile
function bboxByTile(z, x, y)
{
	var a = coordsByTile(z, x, y);
	var b = coordsByTile(z, x+1, y+1);
	return new Array(a[0], b[1], b[0], a[1]);
}


// Converts (z,x,y) to coordinates of corner of a tile
function coordsByTile(z, x, y)
{
	z = z-1;
	var normalizedTile = new Array(x/Math.pow(2.0, z), 1.0-(y/Math.pow(2.0, z)));
	var projectedBounds = from4326To900913(new Array(-180.0, -85.0511287798, 180.0, 85.0511287798));
	var maxp = new Array(projectedBounds[2]-projectedBounds[0], projectedBounds[3]-projectedBounds[1]);
	var projectedCoords = new Array((normalizedTile[0]*maxp[0])+projectedBounds[0], (normalizedTile[1]*maxp[1])+projectedBounds[1]);
	return from900913To4326(projectedCoords);
}


// add a tile to the queue
function addTileToQueue(z, x, y)
{
	var tile = new Array(z, x, y);

	if (!queueElementExists(queue, tile))
		queue.push(tile);
}


// waits sec seconds before continuing to render the tiles from the queue
function wait(sec)
{
	setTimeout(function()
	{
		eventEmitter.emit('tileFinished');
	}, sec*1000);
}


// returns true if element is already in the list queue, otherwise false is returned
function queueElementExists(queue, element)
{
	for (var queueIndex=0; queueIndex<queue.length; queueIndex++)
		if ((queue[queueIndex][0] == element[0]) && (queue[queueIndex][1] == element[1]) && (queue[queueIndex][2] == element[2]))
			return true;

	return false;
}


// returns true if the tile was marked as expired, otherwise false is returned
function isTileExpired(zoom, x, y)
{
	var filepath = configuration.vtiledir+'/'+zoom+'/'+x+'/'+y+'.json';

	if (fs.existsSync(filepath))
	{
		var stats = fs.statSync(configuration.vtiledir+'/'+zoom+'/'+x+'/'+y+'.json');
		return (stats.mtime.getFullYear() == "1970") ? true : false;
	}
	return false;
}


// render all tiles that are in the queue
function renderQueue()
{
	// removes a tile from the queue if rendered and renders the next tile
	var tileFinished = function renderNextTile()
	{
		if (queue.length > 0)
		{
			logger.debug('Checking system load...');
			if (os.loadavg()[0] <= cpus+1)
			{
				logger.debug('Rendering next tile in the queue...');
				var tile = queue.shift();
				renderQueueElement(tile);
			}
			else
			{
				logger.info('System load too high, will retry after 5 seconds...');
				wait(5);
			}
		}
		else
		{
			logger.info('All tiles rerendered. Queue empty.');
			wait(30);
		}
	}
	eventEmitter.on('tileFinished', tileFinished);

	eventEmitter.emit('tileFinished');
}


// take one tile from the queue and render it
function renderQueueElement(tile)
{
	var zoom = tile[0];
	var x = tile[1];
	var y = tile[2];

	logger.info('z'+zoom+'x'+x+'y'+y+' Rendering tile from the queue.');
	logger.debug('z'+zoom+'x'+x+'y'+y+' Getting vector data...');
	getVectorData(x, y, zoom, function(err, data)
	{
		if (err)
		{
			logger.info('z'+zoom+'x'+x+'y'+y+' Vectortile could not be created. Aborting.');
			eventEmitter.emit('tileFinished');
			return;
		}

		logger.debug('z'+zoom+'x'+x+'y'+y+' Vector data loaded, saving vector tile...');
		saveVectorTile(JSON.stringify(data), x, y, zoom, function(err)
		{
			if (err)
			{
				logger.warn('z'+zoom+'x'+x+'y'+y+' Vector tile could not be saved. Returning.');
				eventEmitter.emit('tileFinished');
				return;
			}

			logger.debug('z'+zoom+'x'+x+'y'+y+' Vector tile saved, rendering bitmap tile...');
			refreshExpiredTile(zoom, x, y, data);
			// remove tile from queue and render next tile if every style was rendered
			logger.debug('z'+zoom+'x'+x+'y'+y+' Finished. Getting the next tile from the queue...');
			eventEmitter.emit('tileFinished');
		});
	});
}


// rerenders all style versions of a tile
function refreshExpiredTile(zoom, x, y, data, selectedStyle)
{
	var selectedStyle = selectedStyle || 0;

	if (selectedStyle >= configuration.styles.length)
		return;

	logger.trace('z'+zoom+'x'+x+'y'+y+' MapCSS style loaded.');
	var filepath = configuration.tiledir+'/'+configuration.styles[selectedStyle]+'/'+zoom+'/'+x;
	renderTile(zoom, x, y, configuration.styles[selectedStyle], data, function(err, image)
	{
		if (err)
		{
			logger.warn('z'+zoom+'x'+x+'y'+y+' Bitmap tile could not be rendered. Returning.');
			refreshExpiredTile(zoom, x, y, data, selectedStyle+1);
			return;
		}

		logger.debug('z'+zoom+'x'+x+'y'+y+' Bitmap tile successfully rendered.');
		logger.debug('z'+zoom+'x'+x+'y'+y+' Creating path '+filepath+'...');
		mkdirp(filepath, function(err)
		{
			if (err)
			{
				logger.error('z'+zoom+'x'+x+'y'+y+' Cannot create path '+filepath+'. Returning.');
				refreshExpiredTile(zoom, x, y, data, selectedStyle+1);
				return;
			}

			logger.debug('z'+zoom+'x'+x+'y'+y+' Saving bitmap tile at path: '+filepath+'/'+y+'.png');
			var out = fs.createWriteStream(filepath+'/'+y+'.png', {mode: 0777});
			var stream = image.createPNGStream();

			// write PNG data stream
			stream.on('data', function(data)
			{
				out.write(data);
			});

			// PNG data stream ended
			stream.on('end', function()
			{
				out.end();
				logger.debug('z'+zoom+'x'+x+'y'+y+' Bitmap tile was saved.');
				refreshExpiredTile(zoom, x, y, data, selectedStyle+1);
				return;
			});
		});
	});
}
